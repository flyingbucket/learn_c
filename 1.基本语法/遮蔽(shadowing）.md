## 遮蔽（Shadowing）

在 C 语言中，如果在某个作用域内定义了一个与外层作用域（例如全局作用域或函数外层作用域）同名的变量，那么这个新的变量会在当前作用域内“遮蔽”（shadow）外层作用域中的同名变量。

这意味着：

- 在当前作用域中，访问到的将是局部定义的新变量；
    
- 外层的同名变量不会被销毁或修改，只是暂时“不可见”；
    
- 一旦离开该局部作用域，外层变量重新可见，并且保持原有值。
    

---

### 函数中的遮蔽

```c
#include <stdio.h>

int x = 10;  // 全局变量 x

void func() {
    int x = 20;  // 局部变量 x，遮蔽了全局变量 x
    printf("Inside func, x = %d\n", x);  // 输出局部变量 x 的值 20
}

int main() {
    printf("Before func, x = %d\n", x);  // 输出全局变量 x 的值 10
    func();
    printf("After func, x = %d\n", x);   // 输出全局变量 x 的值 10
    return 0;
}
```

**输出结果：**

```
Before func, x = 10
Inside func, x = 20
After func, x = 10
```

在 `func` 内重新声明了一个局部变量 `x`，它遮蔽了全局变量 `x`。因此，`func` 内打印的是局部变量的值，而在 `main` 中调用 `func` 前后，全局变量 `x` 保持不变。

---

###  块作用域中的遮蔽

遮蔽不仅能发生在函数内部，也可以发生在代码块（如循环或条件语句）中：

```c
#include <stdio.h>

int x = 10;  // 全局变量

int main() {
    printf("Global x before block: %d\n", x);

    {
        int x = 30;  // 新的局部变量，遮蔽全局变量
        printf("Block x: %d\n", x);
    }

    printf("Global x after block: %d\n", x);
    return 0;
}
```

**输出结果：**

```
Global x before block: 10
Block x: 30
Global x after block: 10
```

在 `{}` 块内声明了一个新的 `x`，它遮蔽了全局变量 `x`。但离开这个块后，新的局部变量生命周期结束，全局变量 `x` 又恢复可见。

---

### 注意事项

1. **遮蔽并不会修改外层变量的值**  
    重新声明的变量只是一个新的实体，生命周期和存储空间都不同，不会影响外层的同名变量。
    
2. **作用域规则优先**  
    在 C 语言中，**就近原则**决定了变量的解析：编译器总是优先使用当前作用域内最接近的声明。
    
3. **易引发混淆**  
    如果在代码中过度使用遮蔽，容易让人误以为操作的是全局变量，实际上却是在修改局部变量。建议实际编程中避免使用相同的变量名。
    

---

### 如何访问被遮蔽的全局变量

在 C 语言里，如果局部变量遮蔽了全局变量，可以通过 **在局部作用域内使用 `extern` 显式声明** 来访问全局变量：

```c
#include <stdio.h>

int x = 10;  // 全局变量

void func() {
    int x = 20;  
    printf("Local x = %d\n", x);  // 输出 20

    extern int x;  // 引用全局变量 x
    printf("Global x = %d\n", x); // 输出 10
}
```

这样可以区分到底访问的是哪一个 `x`。不过，代码可读性会变差，一般不推荐。


 
### 总结

- 遮蔽（shadowing）指的是内层作用域的变量与外层作用域的变量同名，从而让外层变量在该作用域内“不可见”。
    
- 外层变量的值不会因遮蔽而改变，作用域结束后会重新可见。
    
- 实际编程中应尽量避免使用相同的变量名，以减少混淆。
    

---

要不要我再帮你扩展一个 **函数参数遮蔽全局变量** 的示例，让这一节更完整？